var tipuesearch = {"pages":[{"title":" hashkeys ","text":"hashkeys NOTE: This repository requires being built with fpm ( Fortran Package Manager )\n      Alternatively, it may be found as a part of the GPF( General Purpose Fortran ) NAME M_hashkeys - a collection of hash key generator modules DESCRIPTION M_hashkeys(3f) is a Fortran repository that contains several modules \n   of hash generators. DOCUMENTATION USER All documents are contained in the docs/ directory including\narchive files of man(1) pages that can be installed on ULS\n(Unix-Like Systems). Individual man-pages as HTML HTML versions of the man-pages describe all the routines:\n   - An index to M_hashkeys.f90 and M_sha3.f90 All man-pages amalgamated as HTML Another view of these documents (that uses javascript to combine all\n   the HTML descriptions of the man-pages) is in a form that can easily be printed as a single document.\n   - BOOK_M_hashkeys - BOOK_M_sha3 real man-pages manpages.zip manpages.tgz CHANGELOG provides a history of significant changes DEVELOPER doxygen(1) output . ford(1) output . github action status DOWNLOAD AND BUILD fpm Download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) bash\n        git clone https://github.com/urbanjost/M_hashkeys.git\n        cd M_hashkeys\n        fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_hashkeys = { git = \"https://github.com/urbanjost/M_hashkeys.git\" } — Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"hasher.f90 – hashkeys","text":"Contents Programs hash_exe Subroutines help_usage help_version Source Code hasher.f90 Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   hasher(1f) - [M_hashkeys] exercise the string hash methods in the M_hashkey(3fm) module                                      ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   hasher [ input_files [ -hash hashname] ]|[ -string string_value]|--help|--version                                            ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   hasher(1f) does a byte by byte hash of a file or a hash of a string                                                          ' ,& '   using the procedures available in the M_hashkey(3fm) module. It is up                                                        ' ,& '   to the user to determine if the method is suitable for a specific use.                                                       ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   input_files  files to generate a hash for                                                                                    ' ,& '   hash         name of hash algorithm. Currently allowed                                                                       ' ,& '                values are:                                                                                                     ' ,& '                                                                                                                                ' ,& '                  djb2 (default)   calls djb2_hash(3f)                                                                          ' ,& '                  sdbm             calls sdbm_hash(3f)                                                                          ' ,& '                  crc32            calls cfc32_hash(3f)                                                                         ' ,& '                                                                                                                                ' ,& '   --help       display this help and exit                                                                                      ' ,& '   --version    output version information and exit                                                                             ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    hasher(1f) - [M_hashkeys] exercise the string hash methods in the M_hashkey(3fm) module !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    hasher [ input_files [ -hash hashname] ]|[ -string string_value]|--help|--version !! !!##DESCRIPTION !!    hasher(1f) does a byte by byte hash of a file or a hash of a string !!    using the procedures available in the M_hashkey(3fm) module. It is up !!    to the user to determine if the method is suitable for a specific use. !! !!##OPTIONS !!    input_files  files to generate a hash for !!    hash         name of hash algorithm. Currently allowed !!                 values are: !! !!                   djb2 (default)   calls djb2_hash(3f) !!                   sdbm             calls sdbm_hash(3f) !!                   crc32            calls cfc32_hash(3f) !! !!    --help       display this help and exit !!    --version    output version information and exit !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        hasher(1f)>' ,& '@(#)DESCRIPTION:    string hash example>' ,& '@(#)VERSION:        20180928>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to>' ,& '@(#)                change and redistribute it.  There is NO WARRANTY;>' ,& '@(#)                without even the implied warranty of MERCHANTABILITY or>' ,& '@(#)                FITNESS FOR A PARTICULAR PURPOSE.>' ,& '@(#)COMPILED:       2022-07-15 23:08:51 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version program hash_exe use , intrinsic :: iso_fortran_env , only : ERROR_UNIT ! access computing environment use , intrinsic :: iso_fortran_env , only : iostat_end use , intrinsic :: ISO_FORTRAN_ENV , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use M_hashkeys , only : djb2_hash , int128 use M_hashkeys , only : sdbm_hash use M_hashkeys , only : crc32_hash use M_kracken , only : kracken , lget , sget , sgets use M_system , only : system_isreg use M_verify , only : debug implicit none integer :: i integer :: ios integer :: icount integer ( kind = int128 ) :: hash integer , parameter :: IUNIT = 15 ! input file unit character ( len = :), allocatable :: string character ( len = 4096 ), allocatable :: filenames (:) character ( len = 4096 ) :: msg character ( len = :), allocatable :: hashname logical :: cont integer , parameter :: bufsize = 1048576 * 32 character ( len = 1 ) :: buff ( bufsize ) integer :: sz integer :: filepoint abstract interface function hashkey ( anything , continue ) import int128 integer ( kind = int128 ) :: hashkey class ( * ), intent ( in ) :: anything (:) logical , intent ( in ), optional :: continue end function hashkey end interface procedure ( hashkey ), pointer :: hash_ptr => null () !----------------------------------------------------------------------------------------------------------------------------------- call kracken ( 'hasher' , ' -hash djb2 -string -version F -help F -verbose F' ) ! crack command-line call help_usage ( lget ( 'hasher_help' )) ! check if help requested call help_version ( lget ( 'hasher_version' )) ! check if version requested string = trim ( sget ( 'hasher_string' )) filenames = sgets ( 'hasher_oo' ) debug = lget ( 'hasher_verbose' ) hashname = trim ( sget ( 'hasher_hash' )) !!  select case(hashname)                                                       ! point to selected function !!  case('djb2'); hash_ptr => djb2_hash !!  case('sdbm'); hash_ptr => sdbm_hash !!  case default !!     write(ERROR_UNIT,*)'*hasher* error: unknown hash method ' !!     stop 3 !!  end select !----------------------------------------------------------------------------------------------------------------------------------- if ( string . ne . '' ) then !!write(*,'(i0,1x,a)')hash_ptr(string),trim(string) select case ( hashname ) ! point to selected function case ( 'skip' ) ; write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) hashname , 0 , len ( string ), string case ( 'djb2' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) hashname , djb2_hash ( string ) , len ( string ), string case ( 'sdbm' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) hashname , sdbm_hash ( string ) , len ( string ), string case ( 'crc32' ); write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) hashname , crc32_hash ( string ) , len ( string ), string case default write ( ERROR_UNIT , * ) '*hasher* error: unknown hash method ' , trim ( hashname ) stop 2 end select endif !----------------------------------------------------------------------------------------------------------------------------------- if ( debug ) then write ( * , * ) 'FILES=' ,( trim ( filenames ( i )), i = 1 , size ( filenames )) endif !----------------------------------------------------------------------------------------------------------------------------------- FILES : do i = 1 , size ( filenames ) ! open file if it is a regular file if (. not . system_isreg ( filenames ( i ))) cycle open ( unit = IUNIT , file = filenames ( i ), status = 'old' , access = 'stream' , iostat = ios , iomsg = msg , action = 'read' ) if ( ios . ne . 0 ) then write ( ERROR_UNIT , '(*(a))' ) '*hasher* error: file ' , trim ( filenames ( i )), ' message=' , trim ( msg ) close ( unit = IUNIT , iostat = ios ) cycle FILES endif cont = . false . ! for initial call use default seed icount = 0 ! count number of characters processed sz = bufsize filepoint = 1 hash = 0_int128 INFINITE : do ! read and sum file string by string ! quick buffering read because reading a single character sixty times slower on CygWIn with gfortran (no system buffering?) read ( iunit , iostat = ios , pos = filepoint ) buff ( 1 : sz ) if ( is_iostat_end ( ios )) then ! this is the last buffer if ( sz . ne . 1 ) then ! try again with a smaller buffer sz = max ( 1 , sz / 2 ) cycle INFINITE endif elseif ( ios == 0 ) then ! no error occurred so successfully read a buffer filepoint = filepoint + sz endif if ( ios /= 0 ) then ! quit reading on error exit INFINITE endif !!hash=hash_ptr(buff(:sz),continue=cont)                    ! build up hash select case ( hashname ) ! point to selected function case ( 'skip' ); case ( 'djb2' ); hash = djb2_hash ( buff (: sz ), continue = cont ) ! build up hash case ( 'sdbm' ); hash = sdbm_hash ( buff (: sz ), continue = cont ) ! build up hash case ( 'crc32' ); hash = crc32_hash ( buff (: sz ), continue = cont ) ! build up hash case default write ( ERROR_UNIT , * ) '*hasher* error: unknown hash method ' , trim ( hashname ) stop 1 end select icount = icount + sz if ( cont . eqv .. false .) cont = . true . ! change flag to continue hash build after first call to accumulate enddo INFINITE if ( icount . eq . 0 ) then write ( ERROR_UNIT , '(*(a))' ) '*hasher* error: file ' , trim ( filenames ( i )), ' is empty' else select case ( hashname ) ! point to selected function case ( 'djb2' , 'sdbm' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) case ( 'crc32' ); write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) case ( 'skip' ); hash = 0_int128 write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) end select endif close ( unit = IUNIT , iostat = ios ) enddo FILES end program hash_exe","tags":"","loc":"sourcefile/hasher.f90.html"},{"title":"sha3.f90 – hashkeys","text":"Contents Programs demo_M_sha3 Source Code sha3.f90 Source Code program demo_M_sha3 ! ident_1=\"@(#)sha3(1f): generate SHA-{224,256,384,512} digest values for specified files\" use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_sha3 , only : sha3_auto_test , sha3_file use M_system , only : system_isreg use M_CLI2 , only : set_args , iget , lget , files => unnamed implicit none integer :: i , ibitsz character ( len = :), allocatable :: fname character ( len = :), allocatable :: help_text (:), version_text (:) call setup () call set_args ( ' --bits 256 --auto_test F' , help_text , version_text ) if ( lget ( 'auto_test' )) then call sha3_auto_test () endif do i = 1 , size ( files ) ! step through filenames on command line fname = trim ( files ( i )) if (. not . system_isreg ( fname )) cycle select case ( ibitsz ) case ( 224 , 256 , 384 , 512 ) ; call sha3_file ( ibitsz , fname ) case default ; write ( ERROR_UNIT , * ) '\"usage: \"sha3 -a\" or \"sha3 [ -bits [224|256|384|512] fname(s)\"' end select enddo contains subroutine setup () help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME' ,& '   sha3(1) - [FUNIX:M_strings] generate SHA-{224,256,384,512} digest' ,& '   values for specified files' ,& '   (LICENSE:PD)' ,& '' ,& 'SYNOPSIS' ,& '       sha3 [--bits [224|256|384|512] [--auto_test] FILE...' ,& '' ,& 'DESCRIPTION' ,& '   Example of using M_sha3(3fm) module. Calculates SHA digest values' ,& '   for specified files.' ,& '' ,& '   NOT CURRENTLY WORKING' ,& '' ,& 'OPTIONS' ,& ' --bits,b  NNN where NNN is the digest value size in bits.' ,& '' ,& '             +224   calculate SHA-224 digest values for specified files' ,& '             +256   calculate SHA-256 digest values for specified files' ,& '                    (default)' ,& '             +384   calculate SHA-384 digest values for specified files' ,& '             +512   calculate SHA-512 digest values for specified files' ,& '' ,& ' --auto_test,a      run internal tests of routines in M_sha3(3fm) module' ,& '' ,& '   FILE(S)          names of files to generate a hash for.' ,& '' ,& 'EXAMPLES' ,& '  Sample usage' ,& '     sha3 *' ,& '     sha3 --bits 512 *' ,& '' ,& '' ] !> !!##NAME !!    sha3(1) - [FUNIX:M_strings] generate SHA-{224,256,384,512} digest !!    values for specified files !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!        sha3 [--bits [224|256|384|512] [--auto_test] FILE... !! !!##DESCRIPTION !!    Example of using M_sha3(3fm) module. Calculates SHA digest values !!    for specified files. !! !!    NOT CURRENTLY WORKING !! !!##OPTIONS !!  --bits,b  NNN where NNN is the digest value size in bits. !! !!              +224   calculate SHA-224 digest values for specified files !!              +256   calculate SHA-256 digest values for specified files !!                     (default) !!              +384   calculate SHA-384 digest values for specified files !!              +512   calculate SHA-512 digest values for specified files !! !!  --auto_test,a      run internal tests of routines in M_sha3(3fm) module !! !!    FILE(S)          names of files to generate a hash for. !! !!##EXAMPLES !! !!   Sample usage !!      sha3 * !!      sha3 --bits 512 * version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF library utilities and examples>' ,& '@(#)PROGRAM:        sha3(1)>' ,& '@(#)DESCRIPTION:    generate SHA digest values for specified files>' ,& '@(#)VERSION:        1.0-20220715>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '' ] end subroutine setup end program demo_M_sha3","tags":"","loc":"sourcefile/sha3.f90.html"},{"title":"main.f90 – hashkeys","text":"Contents Programs main Source Code main.f90 Source Code program main implicit none print * , \"hello from project hashkeys\" end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"digest.f90 – hashkeys","text":"Contents Programs demo_sha256 Source Code digest.f90 Source Code !> !!##NAME !!    digest(1f) - [FUNIX] compute SHA256 message digest !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    digest FILE... !! !!##DESCRIPTION !!    digest(1f) prints SHA256 (256-bit) checksums. The sums are computed !!    as described in FIPS-180-2. For each regular file listed on the !!    command line a line is printed with the checksum, a byte count and !!    the name of the file. !! !!    It exercises the sha256(3f) routine. Note that it reads the files !!    one at a time into dynamically allocated memory. !! !!##EXAMPLES !! !!    Sample commands !! !!     digest  * !!      FF1A6FB5327CBCEB6E32BCAB543FA71C3033C196EB84E122722C3FD6208360FF     1049831 c1-1-tirupathi.pdf !!      F61B2FF27B5268B9FB6DAD7BBA76D1072D046349D7E767BEEFC3AB2CA72CA95B      109119 in-1 !!      B01911225398AC1371DF8F1D72CBE8AA2E677EDD855E830B2E073439057202EA        4591 newbugs.f90 !!      52E4A0D9ACDD801D62AD497D57B143E5A2E0A56EAD0EA587D14F299EDBC3C8C9        4505 record.sh !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !! Public Domain program demo_sha256 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_hashkeys , only : sha256 , test_suite_sha256 use M_io , only : slurp use M_strings , only : switch use M_system , only : system_isreg implicit none ! ident_1=\"@(#)sha256(1f): read file into memory and generate SHA-256 digest value\" character ( len = 1 ), allocatable :: text (:) ! array to hold file in memory character ( len = :), allocatable :: string integer :: i = 0 character ( len = 4096 ) :: filename do i = 1 , command_argument_count () ! step through filenames on command line call get_command_argument ( i , filename ) if (. not . system_isreg ( filename )) cycle ! ignore anything except regular files call slurp ( filename , text ) ! allocate character array and copy file into it if (. not . allocated ( text )) then write ( ERROR_UNIT , * ) '*sha256* ERROR: failed to load file ' // trim ( filename ) else string = switch ( text ) ! switch array to a single character variable deallocate ( text ) ! release memory write ( * , * ) sha256 ( string ), len ( string ), trim ( filename ) ! write digest value endif enddo if ( i . le . 1 ) call test_suite_sha256 () end program demo_sha256","tags":"","loc":"sourcefile/digest.f90.html"},{"title":"hashkey – hashkeys","text":"abstract interface function hashkey(anything, continue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int128)","tags":"","loc":"interface/hashkey.html"},{"title":"help_usage – hashkeys","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   hasher(1f) - [M_hashkeys] exercise the string hash methods in the M_hashkey(3fm) module                                      ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   hasher [ input_files [ -hash hashname] ]|[ -string string_value]|--help|--version                                            ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   hasher(1f) does a byte by byte hash of a file or a hash of a string                                                          ' ,& '   using the procedures available in the M_hashkey(3fm) module. It is up                                                        ' ,& '   to the user to determine if the method is suitable for a specific use.                                                       ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   input_files  files to generate a hash for                                                                                    ' ,& '   hash         name of hash algorithm. Currently allowed                                                                       ' ,& '                values are:                                                                                                     ' ,& '                                                                                                                                ' ,& '                  djb2 (default)   calls djb2_hash(3f)                                                                          ' ,& '                  sdbm             calls sdbm_hash(3f)                                                                          ' ,& '                  crc32            calls cfc32_hash(3f)                                                                         ' ,& '                                                                                                                                ' ,& '   --help       display this help and exit                                                                                      ' ,& '   --version    output version information and exit                                                                             ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage.html"},{"title":"help_version – hashkeys","text":"subroutine help_version(l_version) NAME hasher ( 1 f ) - [ M_hashkeys ] exercise the string hash methods in the M_hashkey ( 3 fm ) module ( LICENSE : PD ) SYNOPSIS hasher [ input_files [ -hash hashname] ]|[ -string string_value]|--help|--version DESCRIPTION hasher ( 1 f ) does a byte by byte hash of a file or a hash of a string using the procedures available in the M_hashkey ( 3 fm ) module . It is up to the user to determine if the method is suitable for a specific use . OPTIONS input_files files to generate a hash for hash name of hash algorithm . Currently allowed values are : djb2 ( default ) calls djb2_hash ( 3 f ) sdbm calls sdbm_hash ( 3 f ) crc32 calls cfc32_hash ( 3 f ) -- help display this help and exit -- version output version information and exit AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        hasher(1f)>' ,& '@(#)DESCRIPTION:    string hash example>' ,& '@(#)VERSION:        20180928>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to>' ,& '@(#)                change and redistribute it.  There is NO WARRANTY;>' ,& '@(#)                without even the implied warranty of MERCHANTABILITY or>' ,& '@(#)                FITNESS FOR A PARTICULAR PURPOSE.>' ,& '@(#)COMPILED:       2022-07-15 23:08:51 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version.html"},{"title":"setup – hashkeys","text":"subroutine setup() NAME sha3 ( 1 ) - [ FUNIX : M_strings ] generate SHA - { 224 , 256 , 384 , 512 } digest values for specified files ( LICENSE : PD ) SYNOPSIS sha3 [--bits [224|256|384|512] [--auto_test] FILE... DESCRIPTION Example of using M_sha3 ( 3 fm ) module . Calculates SHA digest values for specified files . NOT CURRENTLY WORKING OPTIONS –bits,b  NNN where NNN is the digest value size in bits. + 224 calculate SHA - 224 digest values for specified files + 256 calculate SHA - 256 digest values for specified files ( default ) + 384 calculate SHA - 384 digest values for specified files + 512 calculate SHA - 512 digest values for specified files –auto_test,a      run internal tests of routines in M_sha3(3fm) module FILE ( S ) names of files to generate a hash for . EXAMPLES Sample usage\n      sha3 *\n      sha3 –bits 512 * Arguments None Contents Source Code setup Source Code subroutine setup () help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME' ,& '   sha3(1) - [FUNIX:M_strings] generate SHA-{224,256,384,512} digest' ,& '   values for specified files' ,& '   (LICENSE:PD)' ,& '' ,& 'SYNOPSIS' ,& '       sha3 [--bits [224|256|384|512] [--auto_test] FILE...' ,& '' ,& 'DESCRIPTION' ,& '   Example of using M_sha3(3fm) module. Calculates SHA digest values' ,& '   for specified files.' ,& '' ,& '   NOT CURRENTLY WORKING' ,& '' ,& 'OPTIONS' ,& ' --bits,b  NNN where NNN is the digest value size in bits.' ,& '' ,& '             +224   calculate SHA-224 digest values for specified files' ,& '             +256   calculate SHA-256 digest values for specified files' ,& '                    (default)' ,& '             +384   calculate SHA-384 digest values for specified files' ,& '             +512   calculate SHA-512 digest values for specified files' ,& '' ,& ' --auto_test,a      run internal tests of routines in M_sha3(3fm) module' ,& '' ,& '   FILE(S)          names of files to generate a hash for.' ,& '' ,& 'EXAMPLES' ,& '  Sample usage' ,& '     sha3 *' ,& '     sha3 --bits 512 *' ,& '' ,& '' ] !> !!##NAME !!    sha3(1) - [FUNIX:M_strings] generate SHA-{224,256,384,512} digest !!    values for specified files !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!        sha3 [--bits [224|256|384|512] [--auto_test] FILE... !! !!##DESCRIPTION !!    Example of using M_sha3(3fm) module. Calculates SHA digest values !!    for specified files. !! !!    NOT CURRENTLY WORKING !! !!##OPTIONS !!  --bits,b  NNN where NNN is the digest value size in bits. !! !!              +224   calculate SHA-224 digest values for specified files !!              +256   calculate SHA-256 digest values for specified files !!                     (default) !!              +384   calculate SHA-384 digest values for specified files !!              +512   calculate SHA-512 digest values for specified files !! !!  --auto_test,a      run internal tests of routines in M_sha3(3fm) module !! !!    FILE(S)          names of files to generate a hash for. !! !!##EXAMPLES !! !!   Sample usage !!      sha3 * !!      sha3 --bits 512 * version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF library utilities and examples>' ,& '@(#)PROGRAM:        sha3(1)>' ,& '@(#)DESCRIPTION:    generate SHA digest values for specified files>' ,& '@(#)VERSION:        1.0-20220715>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '' ] end subroutine setup","tags":"","loc":"proc/setup.html"},{"title":"hash_exe – hashkeys","text":"Uses iso_fortran_env iso_fortran_env iso_fortran_env M_hashkeys M_hashkeys M_hashkeys M_kracken M_system M_verify select case(hashname)                                                       ! point to selected function\n  case(‘djb2’); hash_ptr => djb2_hash\n  case(‘sdbm’); hash_ptr => sdbm_hash\n  case default\n     write(ERROR_UNIT, )’ hasher* error: unknown hash method ‘\n     stop 3\n  end select write(*,’(i0,1x,a)’)hash_ptr(string),trim(string)\nhash=hash_ptr(buff(:sz),continue=cont)                    ! build up hash Contents Variables IUNIT buff bufsize cont filenames filepoint hash hash_ptr hashname i icount ios msg string sz Abstract Interfaces hashkey Source Code hash_exe Variables Type Attributes Name Initial integer, parameter :: IUNIT = 15 character(len=1) :: buff (bufsize) integer, parameter :: bufsize = 1048576*32 logical :: cont character(len=4096), allocatable :: filenames (:) integer :: filepoint integer(kind=int128) :: hash procedure( hashkey ), pointer :: hash_ptr => null() character(len=:), allocatable :: hashname integer :: i integer :: icount integer :: ios character(len=4096) :: msg character(len=:), allocatable :: string integer :: sz Abstract Interfaces abstract interface function hashkey(anything, continue) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: anything (:) logical, intent(in), optional :: continue Return Value integer(kind=int128) Source Code program hash_exe use , intrinsic :: iso_fortran_env , only : ERROR_UNIT ! access computing environment use , intrinsic :: iso_fortran_env , only : iostat_end use , intrinsic :: ISO_FORTRAN_ENV , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use M_hashkeys , only : djb2_hash , int128 use M_hashkeys , only : sdbm_hash use M_hashkeys , only : crc32_hash use M_kracken , only : kracken , lget , sget , sgets use M_system , only : system_isreg use M_verify , only : debug implicit none integer :: i integer :: ios integer :: icount integer ( kind = int128 ) :: hash integer , parameter :: IUNIT = 15 ! input file unit character ( len = :), allocatable :: string character ( len = 4096 ), allocatable :: filenames (:) character ( len = 4096 ) :: msg character ( len = :), allocatable :: hashname logical :: cont integer , parameter :: bufsize = 1048576 * 32 character ( len = 1 ) :: buff ( bufsize ) integer :: sz integer :: filepoint abstract interface function hashkey ( anything , continue ) import int128 integer ( kind = int128 ) :: hashkey class ( * ), intent ( in ) :: anything (:) logical , intent ( in ), optional :: continue end function hashkey end interface procedure ( hashkey ), pointer :: hash_ptr => null () !----------------------------------------------------------------------------------------------------------------------------------- call kracken ( 'hasher' , ' -hash djb2 -string -version F -help F -verbose F' ) ! crack command-line call help_usage ( lget ( 'hasher_help' )) ! check if help requested call help_version ( lget ( 'hasher_version' )) ! check if version requested string = trim ( sget ( 'hasher_string' )) filenames = sgets ( 'hasher_oo' ) debug = lget ( 'hasher_verbose' ) hashname = trim ( sget ( 'hasher_hash' )) !!  select case(hashname)                                                       ! point to selected function !!  case('djb2'); hash_ptr => djb2_hash !!  case('sdbm'); hash_ptr => sdbm_hash !!  case default !!     write(ERROR_UNIT,*)'*hasher* error: unknown hash method ' !!     stop 3 !!  end select !----------------------------------------------------------------------------------------------------------------------------------- if ( string . ne . '' ) then !!write(*,'(i0,1x,a)')hash_ptr(string),trim(string) select case ( hashname ) ! point to selected function case ( 'skip' ) ; write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) hashname , 0 , len ( string ), string case ( 'djb2' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) hashname , djb2_hash ( string ) , len ( string ), string case ( 'sdbm' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) hashname , sdbm_hash ( string ) , len ( string ), string case ( 'crc32' ); write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) hashname , crc32_hash ( string ) , len ( string ), string case default write ( ERROR_UNIT , * ) '*hasher* error: unknown hash method ' , trim ( hashname ) stop 2 end select endif !----------------------------------------------------------------------------------------------------------------------------------- if ( debug ) then write ( * , * ) 'FILES=' ,( trim ( filenames ( i )), i = 1 , size ( filenames )) endif !----------------------------------------------------------------------------------------------------------------------------------- FILES : do i = 1 , size ( filenames ) ! open file if it is a regular file if (. not . system_isreg ( filenames ( i ))) cycle open ( unit = IUNIT , file = filenames ( i ), status = 'old' , access = 'stream' , iostat = ios , iomsg = msg , action = 'read' ) if ( ios . ne . 0 ) then write ( ERROR_UNIT , '(*(a))' ) '*hasher* error: file ' , trim ( filenames ( i )), ' message=' , trim ( msg ) close ( unit = IUNIT , iostat = ios ) cycle FILES endif cont = . false . ! for initial call use default seed icount = 0 ! count number of characters processed sz = bufsize filepoint = 1 hash = 0_int128 INFINITE : do ! read and sum file string by string ! quick buffering read because reading a single character sixty times slower on CygWIn with gfortran (no system buffering?) read ( iunit , iostat = ios , pos = filepoint ) buff ( 1 : sz ) if ( is_iostat_end ( ios )) then ! this is the last buffer if ( sz . ne . 1 ) then ! try again with a smaller buffer sz = max ( 1 , sz / 2 ) cycle INFINITE endif elseif ( ios == 0 ) then ! no error occurred so successfully read a buffer filepoint = filepoint + sz endif if ( ios /= 0 ) then ! quit reading on error exit INFINITE endif !!hash=hash_ptr(buff(:sz),continue=cont)                    ! build up hash select case ( hashname ) ! point to selected function case ( 'skip' ); case ( 'djb2' ); hash = djb2_hash ( buff (: sz ), continue = cont ) ! build up hash case ( 'sdbm' ); hash = sdbm_hash ( buff (: sz ), continue = cont ) ! build up hash case ( 'crc32' ); hash = crc32_hash ( buff (: sz ), continue = cont ) ! build up hash case default write ( ERROR_UNIT , * ) '*hasher* error: unknown hash method ' , trim ( hashname ) stop 1 end select icount = icount + sz if ( cont . eqv .. false .) cont = . true . ! change flag to continue hash build after first call to accumulate enddo INFINITE if ( icount . eq . 0 ) then write ( ERROR_UNIT , '(*(a))' ) '*hasher* error: file ' , trim ( filenames ( i )), ' is empty' else select case ( hashname ) ! point to selected function case ( 'djb2' , 'sdbm' ); write ( * , '(a,1x,i0.20,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) case ( 'crc32' ); write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) case ( 'skip' ); hash = 0_int128 write ( * , '(a,1x,i0.11,1x,i15,1x,a)' ) trim ( hashname ), hash , icount , trim ( filenames ( i )) end select endif close ( unit = IUNIT , iostat = ios ) enddo FILES end program hash_exe","tags":"","loc":"program/hash_exe.html"},{"title":"demo_M_sha3 – hashkeys","text":"Uses iso_fortran_env M_sha3 M_system M_CLI2 Contents Variables fname help_text i ibitsz version_text Subroutines setup Source Code demo_M_sha3 Variables Type Attributes Name Initial character(len=:), allocatable :: fname character(len=:), allocatable :: help_text (:) integer :: i integer :: ibitsz character(len=:), allocatable :: version_text (:) Subroutines subroutine setup () –bits,b  NNN where NNN is the digest value size in bits. Read more… Arguments None Source Code program demo_M_sha3 ! ident_1=\"@(#)sha3(1f): generate SHA-{224,256,384,512} digest values for specified files\" use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_sha3 , only : sha3_auto_test , sha3_file use M_system , only : system_isreg use M_CLI2 , only : set_args , iget , lget , files => unnamed implicit none integer :: i , ibitsz character ( len = :), allocatable :: fname character ( len = :), allocatable :: help_text (:), version_text (:) call setup () call set_args ( ' --bits 256 --auto_test F' , help_text , version_text ) if ( lget ( 'auto_test' )) then call sha3_auto_test () endif do i = 1 , size ( files ) ! step through filenames on command line fname = trim ( files ( i )) if (. not . system_isreg ( fname )) cycle select case ( ibitsz ) case ( 224 , 256 , 384 , 512 ) ; call sha3_file ( ibitsz , fname ) case default ; write ( ERROR_UNIT , * ) '\"usage: \"sha3 -a\" or \"sha3 [ -bits [224|256|384|512] fname(s)\"' end select enddo contains subroutine setup () help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME' ,& '   sha3(1) - [FUNIX:M_strings] generate SHA-{224,256,384,512} digest' ,& '   values for specified files' ,& '   (LICENSE:PD)' ,& '' ,& 'SYNOPSIS' ,& '       sha3 [--bits [224|256|384|512] [--auto_test] FILE...' ,& '' ,& 'DESCRIPTION' ,& '   Example of using M_sha3(3fm) module. Calculates SHA digest values' ,& '   for specified files.' ,& '' ,& '   NOT CURRENTLY WORKING' ,& '' ,& 'OPTIONS' ,& ' --bits,b  NNN where NNN is the digest value size in bits.' ,& '' ,& '             +224   calculate SHA-224 digest values for specified files' ,& '             +256   calculate SHA-256 digest values for specified files' ,& '                    (default)' ,& '             +384   calculate SHA-384 digest values for specified files' ,& '             +512   calculate SHA-512 digest values for specified files' ,& '' ,& ' --auto_test,a      run internal tests of routines in M_sha3(3fm) module' ,& '' ,& '   FILE(S)          names of files to generate a hash for.' ,& '' ,& 'EXAMPLES' ,& '  Sample usage' ,& '     sha3 *' ,& '     sha3 --bits 512 *' ,& '' ,& '' ] !> !!##NAME !!    sha3(1) - [FUNIX:M_strings] generate SHA-{224,256,384,512} digest !!    values for specified files !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!        sha3 [--bits [224|256|384|512] [--auto_test] FILE... !! !!##DESCRIPTION !!    Example of using M_sha3(3fm) module. Calculates SHA digest values !!    for specified files. !! !!    NOT CURRENTLY WORKING !! !!##OPTIONS !!  --bits,b  NNN where NNN is the digest value size in bits. !! !!              +224   calculate SHA-224 digest values for specified files !!              +256   calculate SHA-256 digest values for specified files !!                     (default) !!              +384   calculate SHA-384 digest values for specified files !!              +512   calculate SHA-512 digest values for specified files !! !!  --auto_test,a      run internal tests of routines in M_sha3(3fm) module !! !!    FILE(S)          names of files to generate a hash for. !! !!##EXAMPLES !! !!   Sample usage !!      sha3 * !!      sha3 --bits 512 * version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF library utilities and examples>' ,& '@(#)PROGRAM:        sha3(1)>' ,& '@(#)DESCRIPTION:    generate SHA digest values for specified files>' ,& '@(#)VERSION:        1.0-20220715>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '' ] end subroutine setup end program demo_M_sha3","tags":"","loc":"program/demo_m_sha3.html"},{"title":"main – hashkeys","text":"Contents Source Code main Source Code program main implicit none print * , \"hello from project hashkeys\" end program main","tags":"","loc":"program/main.html"},{"title":"demo_sha256 – hashkeys","text":"Uses iso_fortran_env M_hashkeys M_io M_strings M_system NAME digest ( 1 f ) - [ FUNIX ] compute SHA256 message digest ( LICENSE : PD ) SYNOPSIS digest FILE... DESCRIPTION digest ( 1f ) prints SHA256 ( 256 - bit ) checksums . The sums are computed as described in FIPS - 180 - 2. For each regular file listed on the command line a line is printed with the checksum , a byte count and the name of the file . It exercises the sha256 ( 3f ) routine . Note that it reads the files one at a time into dynamically allocated memory . EXAMPLES Sample commands\n\n digest  *\n  FF1A6FB5327CBCEB6E32BCAB543FA71C3033C196EB84E122722C3FD6208360FF     1049831 c1-1-tirupathi.pdf\n  F61B2FF27B5268B9FB6DAD7BBA76D1072D046349D7E767BEEFC3AB2CA72CA95B      109119 in-1\n  B01911225398AC1371DF8F1D72CBE8AA2E677EDD855E830B2E073439057202EA        4591 newbugs.f90\n  52E4A0D9ACDD801D62AD497D57B143E5A2E0A56EAD0EA587D14F299EDBC3C8C9        4505 record.sh AUTHOR John S. Urban LICENSE Public Domain Contents Variables filename i string text Source Code demo_sha256 Variables Type Attributes Name Initial character(len=4096) :: filename integer :: i = 0 character(len=:), allocatable :: string character(len=1), allocatable :: text (:) Source Code program demo_sha256 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use M_hashkeys , only : sha256 , test_suite_sha256 use M_io , only : slurp use M_strings , only : switch use M_system , only : system_isreg implicit none ! ident_1=\"@(#)sha256(1f): read file into memory and generate SHA-256 digest value\" character ( len = 1 ), allocatable :: text (:) ! array to hold file in memory character ( len = :), allocatable :: string integer :: i = 0 character ( len = 4096 ) :: filename do i = 1 , command_argument_count () ! step through filenames on command line call get_command_argument ( i , filename ) if (. not . system_isreg ( filename )) cycle ! ignore anything except regular files call slurp ( filename , text ) ! allocate character array and copy file into it if (. not . allocated ( text )) then write ( ERROR_UNIT , * ) '*sha256* ERROR: failed to load file ' // trim ( filename ) else string = switch ( text ) ! switch array to a single character variable deallocate ( text ) ! release memory write ( * , * ) sha256 ( string ), len ( string ), trim ( filename ) ! write digest value endif enddo if ( i . le . 1 ) call test_suite_sha256 () end program demo_sha256","tags":"","loc":"program/demo_sha256.html"}]}